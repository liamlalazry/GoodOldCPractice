exercises list:
1) אריזות נתונים: struct / union / enum, יישור ו־padding

א. מיפוי זיכרון בסיסי
כתוב struct עם שדות מסוגים שונים (char, int, short, double).
משימות:

הדפס sizeof(struct) ו־offset של כל שדה (באמצעות printf("%zu", offsetof(...))).

סדר מחדש את השדות כדי להקטין sizeof.
בדיקה: האם sizeof קטן אחרי הסידור?
אתגר: הוסף #pragma pack(push, 1) ובדוק תוצאות/ביצועים/unaligned access (זהירות!).

ב. union להבנת חפיפה
צור union עם uint32_t u32; uint8_t b[4];.
משימות:

כתוב ל־u32 ערך כמו 0x11223344 והדפס את b[0..3].

הסק את ה־endianness.
אתגר: הוסף שדה float f; ותרגם בין ייצוגים של u32↔float.

ג. enum עם ערכי ביטים
צור enum לדגלים (READ=1, WRITE=2, EXEC=4).
משימות:

כתוב פונקציה שמקבלת מסכה ומדפיסה אילו דגלים דלוקים.
אתגר: הוסף “combos” וודא שאין התנגשות ערכים.

2) אריתמטיקת מצביעים

א. חישוב offset ידני
הקצה מערך uint16_t a[8].
משימות:

כתוב פונקציה שמחזירה מצביע לאיבר ה־i בלי להשתמש בסוגריים מרובעים (רק עם מצביע ובניהול offset).
בדיקה: השווה ל־&a[i].

ב. T* מול void*
כתיבה של memset16(void* dst, uint16_t value, size_t count) שממלאת 16־ביט.
בדיקה: בדוק על buffer והדפס hex.
אתגר: הפוך ל־memcpy32—שים לב ליישור.

ג. מצביע למערך
הגדר int (*p)[3] למטריצה 3 עמודות.
משימות:

כתוב פונקציה שמקבלת int (*m)[3] ו־rows ומדפיסה מטריצה.
בדיקה: ודא גישה נכונה לשורה/עמודה.

3) מערכים ומחרוזות

א. מימוש עצמאי בטוח
ממש size_t my_strlen(const char*) בלי לחרוג מהגבול.
בדיקה: השווה ל־strlen. הוסף תיבות בדיקה עם "", "abc", מחרוזות ארוכות.

ב. memcpy מינימלי
ממש void* my_memcpy(void* d, const void* s, size_t n) (ללא חפיפה).
בדיקה: השווה ל־memcmp מול memcpy.
אתגר: הרחב ל־my_memmove (עם חפיפה).

ג. off-by-one
כתיבה ל־buffer בגודל 16 עם snprintf.
משימות:

הדפס את מספר התווים שחזר מ־snprintf והשווה לאורך ה־buffer.
בדיקה: ודא שאין כתיבה מחוץ לגבול.

4) מצביעי פונקציה

א. טבלת פעולות
הגדר טיפוס typedef int (*binop)(int,int);, וממש add/sub/xor.
משימות:

מערך binop ops[] ובחר פעולה לפי אינדקס/מסכה.
בדיקה: ודא קריאות דרך המצביע.

ב. Callback ל־API
ממש for_each(int* arr, size_t n, void (*cb)(int*)) שמשנה מקום.
בדיקה: כתוב cb שמכפיל/מאפס מספרים מסוימים.

ג. חתימות שונות
כתוב דימונסטרציה של טעויות: קרא דרך טיפוס שגוי ובדוק מה קורה (אל תריץ אם יש חשד ל־UB—רק לקומפיל/להבין).

5) const / volatile

א. const ownership
הגדר void take_ro(const int* p); void take_rw(int* p);
משימות:

נסה להעביר מצביע קבוע ל־take_rw (צפה לשגיאת קומפילציה).
הסבר: איפה “שבירת const” מסוכנת.

ב. volatile כמונה־חומרה
הכרז volatile int tick; ועדכן אותו בלולאה נפרדת.
בדיקה: ללא volatile הקומפיילר עלול לאחד קריאות; עם volatile לא.
אתגר: הסתכל ב־ASM ובדוק הבדלי גישה לזיכרון.

6) סוגים, חתימות ו־promotions

א. גלישת סימן
הדגם השוואות בין int8_t, uint8_t ו־int.
משימות:

כתוב ניסויי printf שמראים מתי -1 הופך ל־255 וכד’.
בדיקה: הסבר למה זה קורה (integer promotions).

ב. size_t ו־ptrdiff_t
ממש פונקציה שמחזירה מרחק בין שני מצביעים כ־ptrdiff_t.
בדיקה: הסבר למה size_t לא מתאים כאן.

ג. חתימות אחידות לפונקציות ספריה
נסה לכתוב wrapper ל־strncmp ודאג ש־types תואמים בדיוק.

7) ביטים ואופרטורים

א. פונקציות דגלים
ממש:

set_bit(uint32_t* x, unsigned i)

clear_bit(...)

toggle_bit(...)

test_bit(uint32_t x, unsigned i) → מחזיר 0/1
בדיקה: בדוק עם כמה אינדקסים, הדפס בינארי.

ב. מסכות הרשאות
הגדר enum דגלים ושגרה print_perms(uint32_t mask) שמדפיסה שמות הדגלים הדלוקים.
אתגר: קבל מחרוזת “RWX” והפוך למסכה ולהפך.

ג. שדות ביטים ב־struct
הגדר struct עם unsigned mode:3, type:5, flags:8;.
בדיקה: הדפס ערכים שונים ובדוק sizeof/layout.

8) ניהול זיכרון: calloc/realloc/free וטעויות נפוצות

א. וקטור דינמי קטן
כתוב “vector” למספרים שלמים:

push_back, pop_back, reserve, shrink_to_fit (אופציונלי).
בדיקה: לחץ/שחרר הרבה אלמנטים, בדוק שאין דליפות (Valgrind/ASan אם אפשר).

ב. realloc בטוח
ממש עטיפה בטוחה:

void* xrealloc(void* p, size_t n) {
    void* q = realloc(p, n);
    if (!q) { free(p); /* או לא, בהתאם למדיניות */ }
    return q;
}


בדיקה: הדגם התנהגות כאשר realloc נכשל.

ג. תרחישי באגים

דליפה: שכח free בכוונה—מדוד עם כלי.

double-free: הדגם וראה מה קורה (ב־ASan) — אל תריץ בלי כלי הגנה!

use-after-free: קוד קצר שמצביע נשמר אחרי free—תן לכלי להתריע.

9) ABI בסיסי (הכנה לאסמבלי)

א. פרמטרים על המחסנית (x86)
כתוב 2 פונקציות __cdecl ו־__stdcall שמקבלות 3 פרמטרים.
משימות:

קמפל ל־x86 Release, פתח בדיסאסמבלי, ואפיין מי מנקה את המחסנית.
בדיקה: הבדל ב־ret N מול ret.

ב. ערך חזרה ברגיסטר
פונקציה שמחזירה int ופונקציה שמחזירה struct קטן (למשל שתי מילים).
בדיקה: בדוק איפה הערך חוזר (EAX/EDX, או דרך buffer שהקומפיילר מעביר).

ג. מעבר מצביע לפונקציה
פונקציה שמקבלת int (*f)(int,int) – בדוק בדיסאסמבלי איך מועבר המצביע ואיך נקרא.

10) התנהגות לא מוגדרת (UB) ולמה זה חשוב ב־RE

א. קריאה מחוץ לגבול
כתוב לולאה שקוראת תא אחד מעבר לסוף המערך.
בדיקה: עם ASan/UBSan—ראה הדיווח; ללא כלים—התוצאה “אקראית”.

ב. קריאה למצביע פונקציה בטיפוס שגוי
המר בכוח (cast) למצביע חתימה אחרת וקרא.
בדיקה: לעתים ירוץ “כאילו עובד”, זו דוגמה קלאסית ל־UB.

ג. שימוש במשתנה לא מאותחל
הדפס ערך של int x; לא מאותחל.
בדיקה: קבל אזהרות/דיווחי Sanitizer; הסק למה זה מסוכן.

הערה: הפעל -fsanitize=address,undefined ב־Clang/GCC או השתמש ב־/RTC1 ב־MSVC לפיתוח.

רוטינת בדיקה מומלצת לכל תרגיל

בנה טסט קצר: assertים עם קלטים קטנים/גדולים/קצה.

הדפס State: גדלים (sizeof), offsets (offsetof), כתובות (%p) כשצריך.

בדיקת כלים:

לוגיקה: assert/ctest/doctest (אם אתה משתמש)

זיכרון: Valgrind/ASan

דיסאסמבלי: הפק בינארי Release, פתח ב־IDA/Ghidra/x64dbg והצלב עם הציפיות (ret, פרמטרים, ערך חזרה).
